《0》webpack原理

《1》使用webpack

《2》编译es6/es7

《3》编译ts配置


webpack原理
    https://blog.csdn.net/u014168594/article/details/77198729

    把所有依赖打包成一个bundle.js文件，通过代码分割成单元片段并按需加载
    bundle.js是以模块 id 为记号，通过函数把各个文件依赖封装达到分割效果，如上代码 id 为 0 表示 entry 模块需要的依赖， 1 表示 util1模块需要的依赖
    require资源文件 id 表示该文件需要加载的各个模块，如上代码_webpack_require__(1) 表示 util1.js 模块，__webpack_require__(2) 表示 util2.js 模块
    exports.util1=util1 模块化的体现，输出该模块

    var _util1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/util1.js")
    console.log(_util1__WEBPACK_IMPORTED_MODULE_0__)
			
		
《1》使用webpack
		安装：	
			npm install webpack-cli -g	//全局
			
		使用webpack的几种方式：
			a.webpack命令
			b.webpack配置
			c.第三方脚手架（Vue-cli / Angular-cli / React-starter）

		webpack命令
			webpack -h  //帮助
			webpack -v  //版本
		  

		打包js：
			方式一：
				webpack <entry> [<entry>] <output> --mode=development/product

				注意：指定的文件要存在
					webpack 入口文件 打包后文件(注意文件要存在)
					webpack app.js ./dist/main.js  --mode=development

				
			方式二：配置文件打包
				当配置文件为默认文件名webpack.config.js 直接
				webpack --mode=development
				当自定义配置文件名：
				webpack --config webpack.conf.dev.js --mode=development
		
		

《2》编译es6/es7
    https://www.babeljs.cn/docs/

    Babel : 是一个 JavaScript 编译器;
            用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中,涉及到新语法的转换和缺失特性的修补


    配置过程：
      1.安装：
        npm install --save-dev babel-loader
        npm install --save-dev @babel/core @babel/cli @babel/preset-env
        npm install --save @babel/polyfill
      
      2.在项目的根目录下创建一个命名为 babel.config.js 的配置文件，其内容为：
        const presets = [
          [
            "@babel/env",
            {
              targets: ['> 1%', 'last 2 versions'],
              useBuiltIns: "usage", //按需加载所需要的polyfill
            },
          ],
        ]
        module.exports = { presets }

        <!-- 
          useBuiltIns参数介绍
            false: 不对polyfills做任何操作
            entry: 根据target中浏览器版本的支持，将polyfills拆分引入，仅引入有浏览器不支持的polyfill
            usage(新)：检测代码中ES6/7/8等的使用情况，仅仅加载代码中用到的polyfills 
        -->

      
      3.webpack.config.js配置
        const confBabel = require('./babel.config')
        module: {
          rules: [
            {
              test: /\.js$/,
              exclude: /node_modules/,
              use: [
                {
                  loader: 'babel-loader',
                  options: {
                    presets: confBabel.presets
                  }
                }
              ]
            }
          ]
        }
      
      4.如果全局配置看最下面 .babelrc 配置

    拓展：
      1.babel
        @babel/core
          1.把 js 代码分析成 ast ，方便各个插件(如babel presets)分析语法进行相应的处理。

      2.babel presets 
        1.插件和预设是小型的 JavaScript 程序，用于指导 Babel 如何对代码进行转换。
        2.作用：例如将 ES2015+ 语法转换为 ES5 语法
            es2015
            es2016
            es2017
            
            env 通常使用：包含 es2015-es2017
            babel-preset-env
            babel-preset-stage 0-3

        3.targets 参数
          babel presets 的 targets 参数 (指定js编译到什么js规范的语法)
          targets.browsers : 指定浏览器版本，js编译到什么语法规范
            targets.browsers:['> 1%', 'last 2 versions']
            或者
            targets: {
              edge: "17",
              firefox: "60",
              chrome: "67",
              safari: "11.1",
            }


      3.balbel Polyfill / babel runtime transform
        作用：指定js函数和方法规范，比如 Generator 、Set 、Map、Array.from、Array.prototype.includes 不被@babel/preset-env 解析，balbel Polyfill / babel runtime transform来编译降级
        本质是core-js这个函数库

        《1》Balbel Polyfill
            安装：
              npm install @babel/polyfill --save

              注意：全局垫片，为引用准备的，所以是安装 --save,非--save-dev

            使用：
              在全局的文件头部添加
                import "@babel/polyfill"



        《2》Balbel Runtime Transform
            复用辅助函数的，不会存在代码重复的问题

            有时候语法的转换相对复杂，可能需要一些helper函数，如转换es6的class：
              /* test.js */
              class Test {}


              /* test-compiled.js */
              function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

              var Test = function Test() {
                _classCallCheck(this, Test);
              };
            示例中es6的class需要一个_classCallCheck辅助函数，试想假如我们多个文件中都用到了es6的class，那么每个文件都需要定义一遍_classCallCheck函数，这也是一笔不小的浪费，假如将这些helper函数抽离到一个包中，由所有的文件共同引用则可以减少可观的代码量。

            @babel/runtime:提供了各种各样的helper函数
            @babel/plugin-transform-runtime:帮助自动引入helper函数

            安装：
              cnpm install @babel/plugin-transform-runtime --save-dev
              cnpm install @babel/runtime --save

              注意：局部垫片，为开发框架准备

            使用：
              1、删除options下的presets配置（没有就不用）
              2、在根目录下新建全局配置文件 .babelrc 文件
                注意使用双引号
                /* .babelrc */
                {
                  "presets": [
                    ["@babel/preset-env", {
                      "modules": false,
                      "useBuiltIns": "usage", //按需引入
                      "targets": ['> 1%', 'last 2 versions', 'not ie <= 8']
                    }]
                  ],
                  "plugins": [
                    "@babel/plugin-transform-runtime"
                  ]  
                }
               
                <!-- webpack.config.js -->
                module: {
                  rules: [
                    {
                      test: /\.js$/,
                      exclude: /node_modules/,
                      use: [
                        {
                          loader: 'babel-loader'
                        }
                      ]
                    }
                  ]
                }
    